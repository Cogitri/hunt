       |/**
       | * onyx-log: the generic, fast, multithreading logging library.
       | *
       | * Logger core implementation.
       | *
       | * Copyright: Â© 2015 onyx-itdevelopment
       | *
       | * License: MIT license. License terms written in "LICENSE.txt" file
       | *
       | * Authors: Oleg Nykytenko (onyx), onyx.itdevelopment@gmail.com
       | *
       | * Version: 0.xx
       | *
       | * Date: 20.03.2015
       | */
       |module onyx.core.logger;
       |
       |
       |import onyx.log;
       |import onyx.bundle;
       |
       |
       |@safe:
       |public:
       |
       |/**
       | * Create loggers
       | *
       | * Throws: ConfException, LogCreateException, Exception
       | */
       |@trusted
       |void create(immutable Bundle bundle)
       |{
0000000|        synchronized (lock) 
       |        {
0000000|                foreach(loggerName; bundle.glKeys())
       |                {
0000000|                        if (loggerName in ids)
       |                        {
0000000|                                throw new LogCreateException("Creating logger error. Logger with name: " ~ loggerName ~ " already created");
       |                        }
0000000|                        auto log = new Logger(bundle.subBundle(loggerName));
0000000|                        ids[loggerName] = log;
       |                }
       |        }
       |}
       |
       |
       |/**
       | * Delete loggers
       | *
       | * Throws: Exception
       | */
       |@trusted
       |void delete_(immutable GlKey[] loggerNames)
       |{
0000000|        synchronized (lock) 
       |        {
0000000|                foreach(loggerName; loggerNames)
       |                {
0000000|                        if (loggerName in ids)
       |                        {
0000000|                                ids.remove(loggerName);
       |                        }
       |                }
       |        }
       |}
       |
       |
       |/**
       | * Get created logger
       | *
       | * Throws: LogException
       | */
       |@trusted
       |Log get(immutable string loggerName)
       |{
0000000|        if (loggerName in ids)
       |        {
0000000|                return ids[loggerName];
       |        }
       |        else
       |        {
0000000|                throw new LogException("Getting logger error. Logger with name: " ~ loggerName ~ " not created");
       |        }
       |}
       |
       |
       |/**
       | * Set file for save loggers exception information
       | *
       | * Throws: Exception
       | */
       |@trusted
       |void setErrorFile(immutable string file)
       |{
0000000|        synchronized (lock) 
       |        {
       |                static import onyx.core.controller;
0000000|                onyx.core.controller.createPath(file);
0000000|                errorFile = File(file, "a");
       |        }
       |}
       |
       |
       |/*
       | * Make class member with getter
       | */
       |template addVal(T, string name, string specificator)
       |{
       |        const char[] member = "private " ~ T.stringof ~ " _" ~ name ~"; ";
       |        const char[] getter = "@property nothrow pure " ~ specificator ~ " " ~ T.stringof ~ " " ~ name ~ "() { return _" ~ name ~ "; }";
       |        const char[] addVal = member ~ getter;
       |}
       |
       |/**
       | * Make class member with getter and setter
       | *
       | */
       |template addVar(T, string name, string getterSpecificator, string setterSpecificator)
       |{
       |        const char[] setter = "@property nothrow pure " ~ setterSpecificator ~ " void " ~ name ~ "(" ~ T.stringof ~ " var" ~ ") { _" ~ name ~ " = var; }";
       |        const char[] addVar = addVal!(T, name, getterSpecificator) ~ setter;
       |}
       |
       |/*
       | **************************************************************************************
       | */
       |@system:
       |private:
       |
       |import core.sync.mutex;
       |
       |import std.stdio;
       |
       |import onyx.core.appender;
       |/*
       | * Mutex use for block work with loggers pool
       | */
       |__gshared Mutex lock;
       |
       |
       |/*
       | * Save loggers by names in pool
       | */
       |__gshared Logger[immutable string] ids;
       |
       |
       |/*
       | * Save loggers errors in file
       | */
       |__gshared File errorFile;
       |
       |
       |
       |shared static this()
       |{
      1|        lock = new Mutex();
       |}
       |
       |
       |/*
       | * Logger implementation
       | */
       |class Logger: Log
       |{
       |        /*
       |         * Configuration data
       |         */ 
       |        mixin(addVal!(immutable Bundle, "config", "public"));
       |
       |
       |        /*
       |         * Name
       |         */ 
       |        mixin(addVal!(immutable string, "name", "public"));
       |        
       |        
       |        /*
       |         * Level getter in string type
       |         */ 
       |        public immutable (string) level()
       |        {
0000000|                return mlevel.levelToString();
       |        }
       |        
       |
       |        /*
       |         * Level
       |         */ 
       |        Level mlevel;
       |
       |        
       |        /*
       |         * Appender
       |         */
       |        Appender appender;
       |        
       |
       |        /*
       |         * Encoder
       |         */
       |        Encoder encoder;
       |        
       |        
       |        /*
       |         * Create logger impl
       |         *
       |         * Throws: LogCreateException, ConfException
       |         */
0000000|        this(immutable Bundle bundle)
       |        {
0000000|                _config = bundle;
0000000|                _name = bundle.glKeys[0];
0000000|                mlevel = bundle.value(name, "level").toLevel;
       |                
0000000|                appender = createAppender(bundle);
0000000|                encoder = new Encoder(bundle);
       |        }
       |        
       |        
       |        /*
       |         * Extract logger type from bundle
       |         *
       |         * Throws: BundleException, LogCreateException
       |         */
       |        @trusted /* Object.factory is system */
       |        Appender createAppender(immutable Bundle bundle)
       |        {
       |                try
       |                {
0000000|                        string appenderType = bundle.value(name, "appender");
0000000|                        AppenderFactory f = cast(AppenderFactory)Object.factory("onyx.core.appender." ~ appenderType ~ "Factory");
       |                        
0000000|                        if (f is null)
       |                        {
0000000|                                throw new  LogCreateException("Error create log appender: " ~ appenderType  ~ "  is Illegal appender type from config bundle.");
       |                        }
       |                        
0000000|                        Appender a = f.factory(bundle);
0000000|                        return a;
       |                }
       |                catch (BundleException e)
       |                {
0000000|                        throw new BundleException("Error in Config bundle. [" ~ name ~ "]:" ~ e.msg);
       |                }
       |                catch (Exception e)
       |                {
0000000|                        throw new LogCreateException("Error in creating appender for logger: " ~ name ~ ": " ~ e.msg);
       |                }
       |        }
       |        
       |
       |        /*
       |         * Write message with level "debug" to logger
       |         */
       |        void debug_(lazy const string msg) nothrow
       |        {
0000000|                putMsg(msg, Level.debug_);
       |        }
       |
       |
       |        /*
       |         * Write message with level "info" to logger
       |         */
       |        void info(lazy const string msg) nothrow
       |        {
0000000|                putMsg(msg, Level.info);
       |        }
       |        
       |
       |        /*
       |         * Write message with level "warning" to logger
       |         */
       |        void warning(lazy const string msg) nothrow
       |        {
0000000|                putMsg(msg, Level.warning);
       |        }
       |        
       |
       |        /*
       |         * Write message with level "error" to logger
       |         */
       |        void error(lazy const string msg) nothrow
       |        {
0000000|                putMsg(msg, Level.error);
       |        }
       |        
       |
       |        /*
       |         * Write message with level "critical" to logger
       |         */
       |        void critical(lazy const string msg) nothrow
       |        {
0000000|                putMsg(msg, Level.critical);
       |        }
       |        
       |
       |        /*
       |         * Write message with level "fatal" to logger
       |         */
       |        void fatal(lazy const string msg) nothrow
       |        {
0000000|                putMsg(msg, Level.fatal);
       |        }
       |        
       |
       |        /*
       |         * Encode message and put to appender
       |         */
       |        @trusted
       |        void putMsg(lazy string msg, Level level) nothrow
       |        {
0000000|                string fmsg;
0000000|                if (level >= mlevel)
       |                {
       |                        try
       |                        {
0000000|                                fmsg = encoder.encode(msg, level);
       |                        }
       |                        catch (Exception e)
       |                        {
       |                                try
       |                                {
0000000|                                        fmsg = encoder.encode("Error in encode log message: " ~ e.msg, Level.error);
       |                                }
       |                                catch (Exception ee)
       |                                {
0000000|                                        fixException(ee);
       |                                }
       |                        }
       |                        try
       |                        {
0000000|                                appender.append(fmsg);
       |                        }
       |                        catch (Exception e)
       |                        {
0000000|                                fixException(e);
       |                        }
       |                }
       |        }
       |
       |
       |        /**
       |         * Logger exeption handler
       |         */
       |        @trusted
       |        void fixException (Exception e) nothrow
       |        {
       |                try
       |                {
0000000|                        synchronized(lock)
       |                        {
0000000|                                errorFile.writeln("Error to work with log-> " ~ name ~ " Exception-> "  ~ e.msg);
       |                        }       
       |                }
       |                catch(Exception e){}
       |        }       
       |}
       |
       |
       |class Encoder
       |{
       |        import std.datetime;
       |        
       |        /*
       |         * Name
       |         */ 
       |        mixin(addVal!(immutable string, "name", "private"));
       |        
       |        
       |        /*
       |         * Build encoder
       |         */ 
0000000|        this(immutable Bundle bundle) pure nothrow
       |        {
0000000|                _name = bundle.glKeys[0];
       |        }
       |        
       |        
       |        /**
       |         * Do make message finish string
       |         *
       |         * Throws: Exception
       |         */ 
       |        immutable (string) encode (immutable string message, immutable Level level)
       |        {
       |                import std.string;
0000000|                return format("%-27s [%s] %s- %s", Clock.currTime.toISOExtString(), levelToString(level), name, message);
       |        }
       |}
       |
       |
       |
       |/*
       | * Level type
       | */
       |enum Level:int
       |{
       |        debug_ = 1,
       |        info = 2,
       |        warning = 3,
       |        error = 4,
       |        critical = 5,
       |        fatal = 6
       |}
       |
       |
       |/*
       | * Convert level from string type to Level
       | */
       |Level toLevel(string str)
       |{
0000000|        Level l;
0000000|        switch (str)
       |        {
0000000|                case "debug":
0000000|                        l = Level.debug_;
0000000|                        break;
0000000|                case "info":
0000000|                        l = Level.info;
0000000|                        break;
0000000|                case "warning":
0000000|                        l = Level.warning;
0000000|                        break;
0000000|                case "error":
0000000|                        l = Level.error;
0000000|                        break;
0000000|                case "critical":
0000000|                        l = Level.critical;
0000000|                        break;
0000000|                case "fatal":
0000000|                        l = Level.fatal;
0000000|                        break;                  
0000000|                default:
0000000|                        throw new LogCreateException("Error log level value: " ~ str);
       |        }
0000000|        return l;
       |}
       |
       |
       |/*
       | * Convert level from Level type to string
       | */
       |@safe
       |string levelToString(Level level)
       |{
0000000|        string l;
0000000|        final switch (level)
       |        {
0000000|                case Level.debug_:
0000000|                        l = "debug";
0000000|                        break;
0000000|                case Level.info:
0000000|                        l = "info";
0000000|                        break;
0000000|                case Level.warning:
0000000|                        l = "warning";
0000000|                        break;
0000000|                case Level.error:
0000000|                        l = "error";
0000000|                        break;
0000000|                case Level.critical:
0000000|                        l = "critical";
0000000|                        break;
0000000|                case Level.fatal:
0000000|                        l = "fatal";
0000000|                        break;                  
       |        }
0000000|        return l;
       |}
       |
       |
..\..\..\..\AppData\Roaming\dub\packages\onyx-log-1.2.1-rc3\onyx-log\source\onyx\core\logger.d is 1% covered
