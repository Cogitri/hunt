       |/**
       | * onyx-log: the generic, fast, multithreading logging library.
       | *
       | * Output Controllers implementation.
       | *
       | * Copyright: Â© 2015 onyx-itdevelopment
       | *
       | * License: MIT license. License terms written in "LICENSE.txt" file
       | *
       | * Authors: Oleg Nykytenko (onyx), onyx.itdevelopment@gmail.com
       | *
       | * Version: 0.xx
       | *
       | * Date: 13.05.2015
       | */
       |
       |module onyx.core.controller;
       |
       |
       |@system:
       |package:
       |
       |import onyx.log;
       |import onyx.core.logger;
       |import onyx.bundle;
       |
       |
       |struct Controller
       |{
       |        import std.stdio;
       |        import std.file;
       |
       |        /**
       |         * Currently Logging file
       |         */
       |        File activeFile;
       |        
       |        
       |        /**
       |         * Do file rolling
       |         */
       |        Rollover rollover;
       |        
       |        
       |        /*
       |         * Name
       |         */ 
       |        mixin(addVal!(immutable string, "name", "public"));
       |        
       |        
       |        /**
       |         * Primary constructor
       |         *
       |         * Save config path and name
       |         */
0000000|    this(immutable Bundle bundle)
       |    {
       |        
0000000|        rollover = createRollover(bundle);
       |        
0000000|        _name = bundle.glKeys[0];
       |        
0000000|                createPath(rollover.activeFilePath());
0000000|        activeFile = File(rollover.activeFilePath(), "a");
       |    }
       |    
       |    
       |    /**
       |         * Extract logger type from bundle
       |         *
       |         * Throws: BundleException, LogCreateException
       |         */
       |        @trusted /* Object.factory is system */
       |        Rollover createRollover(immutable Bundle bundle)
       |        {
       |                try
       |                {
0000000|                        if (!bundle.isValuePresent(bundle.glKeys[0], "rolling"))
       |                        {
0000000|                                return new Rollover(bundle);
       |                        }
0000000|                        string rollingType = bundle.value(bundle.glKeys[0], "rolling"); 
0000000|                        RolloverFactory f = cast(RolloverFactory)Object.factory("onyx.core.controller." ~ rollingType ~ "Factory");
       |                        
0000000|                        if (f is null)
       |                        {
0000000|                                throw new  LogCreateException("Error create log rolling: " ~ rollingType  ~ "  is Illegal rolling type from config bundle.");
       |                        }
       |                        
0000000|                        Rollover r = f.factory(bundle);
0000000|                        return r;
       |                }
       |                catch (BundleException e)
       |                {
0000000|                        throw new BundleException("Error in Config bundle. [" ~ name ~ "]:" ~ e.msg);
       |                }
       |                catch (Exception e)
       |                {
0000000|                        throw new LogCreateException("Error in creating rolling for logger: " ~ name ~ ": " ~ e.msg);
       |                }
       |        }
       |        
       |        
       |        /**
       |         * Extract logger type from bundle
       |         *
       |         * Throws: $(D ErrnoException)
       |         */
       |        void saveMsg(string msg)
       |    {
0000000|        if ((!activeFile.name.exists) || rollover.roll(msg))
       |        {
0000000|                activeFile = File(rollover.activeFilePath(), "w");
       |        }
0000000|        else if (!activeFile.isOpen())
       |        {
0000000|                activeFile.open("a");
       |        }
0000000|                activeFile.writeln(msg);
       |                //flush();
       |    }
       |    
       |    
       |    /**
       |         * Flush log file
       |         */
       |    void flush()
       |    {
0000000|        activeFile.flush;
       |    }
       |
       |
       |                
       |}
       |
       |
       |
       |/**
       | * Create file
       | */
       |void createPath(string fileFullName)
       |{
       |        import std.path:dirName;
       |        import std.file:mkdirRecurse;
       |        import std.file:exists;
       |        
0000000|        string dir = dirName(fileFullName);
       |
0000000|        if ((dir.length != 0) && (!exists(dir)))
       |        {
0000000|                mkdirRecurse(dir);
       |        }
       |}
       |
       |
       |
       |
       |
       |/**
       | * Rollover Creating interface
       | *
       | * Use by Controller for create new Rollover
       | *
       | * ====================================================================================
       | */ 
       |interface RolloverFactory
       |{
       |        Rollover factory(immutable Bundle bundle);
       |}
       |
       |
       |/**
       | * Base rollover class
       | */
       |class Rollover
       |{
       |        import std.path;
       |        import std.string;
       |        import std.typecons;
       |        
       |        
       |        /**
       |         * Control of size and number of log files
       |         */
       |        immutable Bundle bundle;
       |        
       |
       |        /**
       |         * Path and file name template
       |         */
       |        mixin(addVal!(immutable string, "path", "protected"));
       |        
       |        
       |        /**
       |         * Work diroctory
       |         */
       |        mixin(addVal!(immutable string, "dir", "protected"));
       |        
       |        
       |        /**
       |         * Log file base name template
       |         */
       |        mixin(addVal!(immutable string, "baseName", "protected"));
       |        
       |        
       |        /**
       |         * Log file extension
       |         */
       |        mixin(addVal!(immutable string, "ext", "protected"));
       |
       |
       |        /**
       |         * Path to main log file
       |         */
       |        mixin(addVar!(string, "activeFilePath", "protected", "protected"));
       |        
       |        
       |        /**
       |         * Primary constructor
       |         */
0000000|        this(immutable Bundle bundle)
       |        {
0000000|                this.bundle = bundle;
0000000|                _path = bundle.value(bundle.glKeys[0], "fileName");
0000000|                auto fileInfo = parseConfigFilePath(path);
0000000|                _dir = fileInfo[0];
0000000|                _baseName = fileInfo[1];
0000000|                _ext = fileInfo[2];
0000000|                init();
       |        }
       |        
       |
       |        /**
       |         * Rollover start init
       |         */
       |        void init()
       |        {
0000000|                activeFilePath = path;
       |        }
       |        
       |        
       |        /**
       |         * Parse configuration file path and base name and save to members
       |         */
       |    auto parseConfigFilePath(string configFile)
       |    {
0000000|        immutable dir = configFile.dirName;
       |        
0000000|        string fullBaseName = std.path.baseName(configFile);
       |        
0000000|        auto ldotPos = fullBaseName.lastIndexOf(".");
       |        
0000000|        immutable ext = (ldotPos > 0)?fullBaseName[ldotPos+1..$]:"log";
       |        
0000000|        immutable baseName = (ldotPos > 0)?fullBaseName[0..ldotPos]:fullBaseName;
       |        
0000000|        return tuple(dir, baseName, ext);
       |    }
       |        
       |        
       |        /**
       |         * Do files rolling by default
       |         */
       |        bool roll(string msg)
       |        {
0000000|                return false;
       |        }
       |}
       |
       |
       |
       |/**
       | * Factory for SizeBasedRollover
       | *
       | * ====================================================================================
       | */
       |class SizeBasedRolloverFactory:RolloverFactory
       |{
       |        override Rollover factory(immutable Bundle bundle)
       |        {
0000000|                return new SizeBasedRollover(bundle);
       |        }
       |}
       |
       |
       |/**
       | * Control of size and number of log files
       | */
       |class SizeBasedRollover:Rollover
       |{
       |        import std.file;
       |        import std.regex;
       |        import std.algorithm;
       |        import std.array;
       |
       |        
       |        /**
       |         * Max size of one file
       |         */
       |        uint maxSize;
       |        
       |        
       |        /**
       |         * Max number of working files
       |         */
       |        uint maxHistory;
       |        
       |        
       |        /**
       |         * Primary constructor
       |         */
0000000|        this(immutable Bundle bundle)
       |        {
0000000|                super(bundle);
0000000|                maxSize = extractSize(bundle.value(bundle.glKeys[0], "maxSize"));
0000000|                maxHistory = bundle.value!int(bundle.glKeys[0], "maxHistory");
       |        }
       |        
       |        
       |        /**
       |         * Extract number fron configuration data
       |         *
       |         * Throws: LogException
       |         */
       |        uint extractSize(string size)
       |        {
       |                import std.uni : toLower;
       |                import std.uni : toUpper;
       |                import std.conv;
       |                
0000000|                uint nsize = 0;
0000000|                auto n = matchAll(size, regex(`\d*`));
0000000|                if (!n.empty && (n.hit.length != 0))
       |                {
0000000|                        nsize = to!int(n.hit);
0000000|                        auto m = matchAll(size, regex(`\D{1}`));
0000000|                        if (!m.empty && (m.hit.length != 0))
       |                        {
0000000|                                switch(m.hit.toUpper)
       |                                {
0000000|                                        case "K":
0000000|                                                nsize *= KB;
0000000|                                                break;
0000000|                                        case "M":
0000000|                                                nsize *= MB;
0000000|                                                break;
0000000|                                        case "G":
0000000|                                                nsize *= GB;
0000000|                                                break;
0000000|                                        case "T":
0000000|                                                nsize *= TB;
0000000|                                                break; 
0000000|                                        case "P":
0000000|                                                nsize *= PB;
0000000|                                                break;
0000000|                                        default:
0000000|                                                throw new LogException("In Logger configuration uncorrect number: " ~ size);             
       |                                }
       |                        }       
       |                }
0000000|                return nsize;
       |        }
       |        
       |        
       |        enum KB = 1024;
       |        enum MB = KB*1024;
       |        enum GB = MB*1024;
       |        enum TB = GB*1024;
       |        enum PB = TB*1024;
       |        
       |        /**
       |         * Scan work directory
       |         * save needed files to pool
       |         */
       |    string[] scanDir()
       |    {
       |        import std.algorithm.sorting:sort;
0000000|        bool tc(string s)
       |                {
       |                        static import std.path;
0000000|                        auto base = std.path.baseName(s);
0000000|                        auto m = matchAll(base, regex(baseName ~ `\d*\.` ~ ext));
0000000|                        if (m.empty || (m.hit != base))
       |                        {
0000000|                                return false;
       |                        }
0000000|                        return true;
       |                }
       |
0000000|        return std.file.dirEntries(dir, SpanMode.shallow)
0000000|                .filter!(a => a.isFile)
0000000|                .map!(a => a.name)
0000000|                .filter!(a => tc(a))
       |                .array
       |                .sort!("a < b")
       |                .array;
       |    }
       |    
       |    
       |        /**
       |         * Do files rolling by size
       |         */
       |        override
       |        bool roll(string msg)
       |        {
0000000|                auto filePool = scanDir();
0000000|                if (filePool.length == 0)
       |                {
0000000|                        return false;
       |                }
0000000|                if ((getSize(filePool[0]) + msg.length) >= maxSize)
       |                {
       |                        //if ((filePool.front.getSize == 0) throw
0000000|                        if (filePool.length >= maxHistory)
       |                        {
0000000|                                std.file.remove(filePool[$-1]);
0000000|                                filePool = filePool[0..$-1];
       |                        }
0000000|                        carry(filePool);
0000000|                        return true;
       |                }
0000000|                return false;
       |        }
       |        
       |        
       |        /**
       |         * Rename log files
       |         */
       |        void carry(string[] filePool)
       |        {
       |                import std.conv;
       |                
0000000|                foreach_reverse(ref file; filePool)
       |                {
0000000|                        auto newFile = dir ~ "/" ~ baseName ~ to!string(extractNum(file)+1) ~ "." ~ ext;
0000000|                        std.file.rename(file, newFile);
0000000|                        file = newFile;
       |                }
       |        }
       |
       |        
       |        /**
       |         * Extract number from file name
       |         */
       |        uint extractNum(string file)
       |        {
       |                import std.conv;
       |                
0000000|                uint num = 0;
       |                try
       |                {
       |                        static import std.path;
       |                        import std.string;
0000000|                        auto fch = std.path.baseName(file).chompPrefix(baseName);
0000000|                        auto m = matchAll(fch, regex(`\d*`));
       |                        
0000000|                        if (!m.empty && m.hit.length > 0)
       |                        {
0000000|                                num = to!uint(m.hit);
       |                        }
       |                }       
       |                catch (Exception e)
       |                {
0000000|                        throw new Exception("Uncorrect log file name: " ~ file ~ "  -> " ~ e.msg);
       |                }
0000000|                return num;
       |        }
       |        
       |        
       |}
..\..\..\..\AppData\Roaming\dub\packages\onyx-log-1.2.1-rc3\onyx-log\source\onyx\core\controller.d is 0% covered
