       |ï»¿import kiss.aio.AsyncTcpBase;
       |
       |import kiss.event.Poll;
       |import std.conv;
       |import std.stdio;
       |import std.string;
       |import std.conv;
       |
       |class MyHttpChannel : AsyncTcpBase
       |{
0000000|        this(Poll poll)
       |        {
       |                //request must small than 2048.
0000000|                readBuff = new byte[1024];
0000000|                super(poll);
       |        }
       |
       |        override protected bool onEstablished()
       |        {
       |                //writeln("MyHttpChannel connected");
0000000|                return super.onEstablished();
       |        }
       |
       |        bool is_request_finish(ref bool finish, ref string url , ref string strbody)
       |        {
       |                import std.typecons : No;
       |
0000000|                string str = cast(string)_readbuffer[0 .. _index];
0000000|                long header_pos = indexOf(str , "\r\n\r\n");
       |
0000000|                if( header_pos == -1)
       |                {
0000000|                        finish = false;
0000000|                        return true;
       |                }
       |
0000000|                string strlength = "content-length: ";
0000000|                int intlength = 0;
0000000|                long pos = indexOf(str , strlength , 0 , No.caseSensitive);
0000000|                if( pos != -1)
       |                {
0000000|                        long left = indexOf(str , "\r\n" , cast(size_t)pos);
0000000|                        if(pos == -1)
0000000|                                return false;
       |
0000000|                        strlength = cast(string)_readbuffer[cast(size_t)(pos + strlength.length) .. cast(size_t)left];
0000000|                        intlength = to!int(strlength);
       |                }
       |                 
       |                //log(LogLevel.info , "length : " ~ to!string(intlength) ~ "header : " ~ to!string(header_pos));
       |
0000000|                if(header_pos + 4 + intlength == _index)
       |                {
0000000|                        finish = true;
       |                }
       |                else
       |                {
0000000|                        finish = false;
0000000|                        return true;
       |                }
       |
0000000|                long pos_url = indexOf(str , "\r\n");
0000000|                if(pos_url == -1)
0000000|                        return false;
       |
0000000|                auto strs = split(cast(string)_readbuffer[0 .. cast(size_t)pos_url]);
0000000|                if(strs.length < 3)
0000000|                        return false;
       |
0000000|                url = strs[1];
0000000|                strbody = cast(string)_readbuffer[cast(size_t)(pos + 4) .. cast(size_t)_index];
       |
0000000|                return true;
       |        }
       |
       |
       |        bool process_request(string url , string strbody)
       |        {
0000000|                string http_content = "HTTP/1.0 200 OK\r\nServer: kiss\r\nContent-Type: text/plain\r\nContent-Length: 10\r\n\r\nhelloworld";
0000000|                int ret = doWrite(cast(byte[])http_content , null , 
       |                                                delegate void(Object o){
0000000|                                                close();
       |                        });
       |
0000000|                if(ret == 1)
0000000|                        return false;
       |
0000000|                return true;
       |        }
       |
       |
       |        override protected bool doRead(byte[] buffer , int len)
       |        {
       |
0000000|                _index += len;
0000000|                bool finish ;
0000000|                string strurl;
0000000|                string strbody;
       |
       |                //log(LogLevel.info , "index : " ~ to!string(_index));
       |
0000000|                if(!is_request_finish(finish , strurl , strbody))
       |                {
       |                        //log(LogLevel.info  , "parse http request error");
0000000|                        return false;
       |                }
       |
0000000|                if(finish)
       |                {
0000000|                        _index = 0;
0000000|                        return process_request(strurl , strbody);
       |                }
0000000|                else if(_index == _readbuffer.length)
       |                {
       |                        //log(LogLevel.info , "not a http request or buffer is full");
0000000|                        return false;
       |                }
       |
       |
0000000|                return true;
       |        }
       |        
       |        override protected  bool onClose() {
       |                //writeln("MyHttpChannel onClose");
0000000|                return super.onClose();
       |        }
       |
       |        private int _index ;
       |        
       |}
       |
       |
       |
       |
       |
       |
       |int main()
       |{
       |
       |        import kiss.event.GroupPoll;
       |        import kiss.aio.AsyncGroupTcpServer;
       |        import kiss.aio.AsyncTcpServer;
       |
      1|        auto poll = new GroupPoll!();
      1|        auto server = new AsyncGroupTcpServer!MyHttpChannel(poll);
      1|        server.open("0.0.0.0" , 81);
       |
       |
       |
       |
0000000|        poll.start();
0000000|        poll.wait();
       |
0000000|        return 0;
       |}
       |
       |
       |
       |
       |
source\app.d is 5% covered
